import Text.ParserCombinators.Parsec
import Control.Applicative ((<*), (*>), (<*>), (<$>))
import Text.Parsec.Prim (tokenPrim, getPosition)
import Text.Parsec.Pos (SourcePos)

data MToken = LeftParenthes       |
              RightParenthes      |
              Semicolon           |
              BracketBlock String |
              PropIdent String
  deriving (Show, Eq)

data MNode = MNode {
  m_position :: SourcePos,
  m_token    :: MToken
} deriving (Show, Eq)

mToken = terminate '(' LeftParenthes   <|>
         terminate ')' RightParenthes  <|>
         terminate ';' Semicolon       <|>
         try bracketBlock              <|>
         propIdentity
  where
    terminate c m = try $ char c *> return m
    bracketBlock = fmap BracketBlock $ char '[' *> many (noneOf "[]") <* char ']'
    propIdentity = many1 upper >>= \s -> return $ PropIdent s

mySatisfy f =
  tokenPrim (\c -> show c)
  (\pos c _cs -> m_position c)
  (\c -> if f c then Just c else Nothing)

myChar c = mySatisfy $ \x -> (m_token x) == c
myProp s = mySatisfy $ \x -> case (m_token x) of
                               PropIdent s' -> s == s'
                               _            -> False

isPropIdentity t = case t of
                    PropIdent _ -> True
                    _           -> False

myProp2 = mySatisfy $ \x -> isPropIdentity (m_token x)

myBlock = mySatisfy $ \x -> case (m_token x) of
                               BracketBlock _ -> True
                               _              -> False

sgfParser = do many1 s_gameTree
  where
    s_gameTree = do myChar LeftParenthes
                    s_sequence
                    many s_gameTree
                    myChar RightParenthes
    s_sequence = many1 s_node
    s_node     = myChar Semicolon *> many s_property
    s_property = myProp2 *> many1 s_propValue
    s_propValue = myBlock

sgfTokenParser = many1 $ spaces *> mnToken
  where
    mnToken = MNode <$> getPosition <*> mToken

parseSgfToken input = case parse sgfTokenParser "" input of
     Left err  -> []
     Right val -> val

parseSgf input = case parse sgfParser "" input of
  Left  err -> putStrLn $ show err
  Right val -> putStrLn $ show val

main = let a = parseSgfToken "(;A[] ;WW[hgoehoge](;B[]))"
       in parseSgf a
