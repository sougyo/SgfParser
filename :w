import Text.ParserCombinators.Parsec
import Control.Applicative ((<*), (*>), (<*>), (<$>))
import Text.Parsec.Prim (tokenPrim, getPosition)
import Text.Parsec.Pos (SourcePos)

data MToken = LeftParenthes  |
              RightParenthes |
              LeftBracket    |
              RightBracket   |
              Semicolon      |
              Ident String
  deriving (Show, Eq)

data MNode = MNode {
  m_position :: 
  m_token    ::

hoge = terminate '(' LeftParenthes   <|>
       terminate ')' RightParenthes  <|>
       terminate '[' LeftBracket     <|>
       terminate ']' RightBracket    <|>
       terminate ';' Semicolon       <|>
       (many1 alphaNum >>= \s -> return $ Ident s)
  where terminate c m = try $ char c *> return m

hoge2 = 

sgfTokenParser = many1 (spaces *> hoge)

sgfParser = do mySatisfy $ \x -> x == LeftParenthes
               mySatisfy $ \x -> x == RightParenthes

parseSgfToken input = case parse sgfTokenParser "" input of
     Left err  -> []
     Right val -> val

mySatisfy f =
  tokenPrim (\c -> show c)
  (\pos c _cs -> )
  (\c -> if f c then Just c else Nothing)
              
parseSgf input = case parse sgfParser "" input of
  Left  err -> putStrLn $ show err
  Right val -> putStrLn $ show val


main = let a = parseSgfToken "(hoge)"
       in parseSgf a
